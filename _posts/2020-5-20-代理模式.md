---
layout: post
title: 设计模式集合-代理模式
subtitle: 代理模式基本使用
author: luliangwei
date: 2020-3-18
tags: 
  - 设计模式
---

## 1. 原理
我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。
代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。

## 2. 静态代理
静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活。接口一旦新增加方法，目标对象和代理对象都要进行修改；需要对每个目标类都单独写一个代理类。
静态代理实现步骤：
1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口；
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

示例：
```java
public interface SmsService {
  // 1.定义发送短信的接口
  String send(String message);
}

// 2.实现发送短信的接口
public class SmsServiceImpl implements SmsService {
  
  public String send(String message) {
  System.out.println("send message:" + message);
  return message;
  }
}
// 3.创建代理类并同样实现发送短信的接口
public class SmsProxy implements SmsService {

    private final SmsService smsService;

    public SmsProxy(SmsService smsService) {
        this.smsService = smsService;
    }

    @Override
    public String send(String message) {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method send()");
        smsService.send(message);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method send()");
        return null;
    }
}

// 实际使用
public class Main {
  public static void main(String[] args) {
  SmsService smsService = new SmsServiceImpl();
  SmsProxy smsProxy = new SmsProxy(smsService);
  smsProxy.send("java");
  }
}
```

## 3. 动态代理
   不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。

### 3.1 JDK动态代理
#### 3.1.1 JDK动态代理机制
在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。
```java
public static Object newProxyInstance(ClassLoader loader, 
                                      Class<?>[] interfaces, 
                                      InvocationHandler h)
   throws IllegalArgumentException {
   ......
}
```
这个方法一共有 3 个参数：
1. `loader` :类加载器，用于加载代理对象。
2. `interfaces` : 被代理类实现的一些接口；
3. h : 实现了 `InvocationHandler` 接口的对象；
   要实现动态代理的话，`还必须需要实现InvocationHandler` 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现`InvocationHandler` 接口类的 `invoke` 方法来调用。
```java
public interface InvocationHandler {

   /**
    * 你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，
    * 实际会调用到实现InvocationHandler 接口的类的 invoke()方法。
    */
    public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable;
}
```
invoke() 方法有下面三个参数：
1. `proxy` :动态生成的代理类
2. `method` : 与代理类对象调用的方法相对应
3. `args` : 当前 method 方法的参数

#### 3.1.2 JDK动态代理使用步骤
1. 定义一个接口及其实现类；
2. 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
3. 通过 Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h) 方法创建代理对象；

示例：
```java
// 1.定义发送短信的接口
public interface SmsService {
   String send(String message);
}

// 2.实现发送短信的接口
public class SmsServiceImpl implements SmsService {
    public String send(String message) {
  System.out.println("send message:" + message);
  return message;
  }
}

// 3.定义一个 JDK 动态代理类
/**
* 自定义动态代理类
  */
  public class MyInvocationHandler implements InvocationHandler {
  /**
  * 代理类中的真实对象
    */
    private final Object target;

    public MyInvocationHandler (Object target) {
    this.target = target;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
    //调用方法之前，我们可以添加自己的操作
    System.out.println("before method " + method.getName());
    Object result = method.invoke(target, args);
    //调用方法之后，我们同样可以添加自己的操作
    System.out.println("after method " + method.getName());
    return result;
    }
  }

// 4.获取代理对象的工厂类
public class JdkProxyFactory {
  public static Object getProxy(Object target) {
    return Proxy.newProxyInstance(
    target.getClass().getClassLoader(), // 目标类的类加载器
    target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个
    new MyInvocationHandler (target)   // 代理对象对应的自定义 InvocationHandler
    );
  }
}

// 5.实际使用
SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());
smsService.send("java");
```

### 3.2 CGLIB动态代理
#### 3.2.1 介绍
JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。
CGLIB 通过继承方式实现代理，它允许我们在运行时对字节码进行修改和动态生成。
在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。
你需要自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法。
```java
public interface MethodInterceptor
  extends Callback{
  // 拦截被代理类中的方法
  public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy) throws Throwable;
}
```
1. obj : 被代理的对象（需要增强的对象）
2. method : 被拦截的方法（需要增强的方法）
3. args : 方法入参
4. proxy : 用于调用原始方法

#### 3.2.2 CGLIB动态代理使用步骤
1. 定义一个类；
2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；
3. 通过 `Enhancer` 类的 `create()`创建代理类；

示例：
```java
   // 1.实现一个使用阿里云发送短信的类
   public class AliSmsService {
   public String send(String message) {
   System.out.println("send message:" + message);
   return message;
   }
   }

// 2.自定义 MethodInterceptor（方法拦截器）
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
* 自定义MethodInterceptor
  */
  public class DebugMethodInterceptor implements MethodInterceptor {


    /**
     * @param o           被代理的对象（需要增强的对象）
     * @param method      被拦截的方法（需要增强的方法）
     * @param args        方法入参
     * @param methodProxy 用于调用原始方法
     */
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method " + method.getName());
        Object object = methodProxy.invokeSuper(o, args);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method " + method.getName());
        return object;
    }

}

// 3.获取代理类
import net.sf.cglib.proxy.Enhancer;

public class CglibProxyFactory {

    public static Object getProxy(Class<?> clazz) {
        // 创建动态代理增强类
        Enhancer enhancer = new Enhancer();
        // 设置类加载器
        enhancer.setClassLoader(clazz.getClassLoader());
        // 设置被代理类
        enhancer.setSuperclass(clazz);
        // 设置方法拦截器
        enhancer.setCallback(new DebugMethodInterceptor());
        // 创建代理类
        return enhancer.create();
    }
}

// 4. 实际使用
AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);
aliSmsService.send("java");

```
